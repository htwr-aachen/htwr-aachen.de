---
title: All**Gemein**wissen
order: 8
description: random Sachen die vermutlich ganz hilfreich f√ºr die Klausur sind
author: Jonas Schneider
date: 13/02/2023
tags:
  [
    Hinweise,
    Kopplung,
    Koh√§sion,
    Prototyping,
    DevOps,
    Security,
    Architekturmuster,
    Code-Generierung,
    Monti*,
    Versionsverwaltung,
  ]
---

Hier ein paar Sachen, f√ºr die ich keine eigene Seite aufmachen will.

Warum ist SWT eigentlich so random und unstrukturiert. Wof√ºr war dieser kleine Exkurs in UI Design eigentlich?? Wieso gab es den?

oder der Ausflug zu den Programmierparadigmen wie Objektorientierung, warum das ganze nochmal...

## Hinweise zur Klausur

Hier etwas das ich frech kopiere.

-Der Diagrammtyp oben rechts im Kasten ist notwendig und wird m√∂glicherweise Gnadenpunkte bringen. Ein fehlen gibt Punktabzug.
-Bei Klassendiagramme nicht vergessen, das man bei ner Klasse ohne Attributliste irgendwie zeigt, dass die leer ist z.B. indem man da quasi son mini Rechteck zwischen dem Rechteck vom Klassennamen und der Methodenliste hat.
-Bei Objektdiagrammen und auch im Sequenzdiagramm m√ºssen die Namen unterstrichen sein, also Objektidentifikator:Klassenname_des_Objekts
-Beim Sequenzdiagramm sollte, falls ein Objekt returned wird der Objektidentifikator auf dem return-Pfeil sein.
-Wenn ihr irgendwas in nem Diagramm oder in ner Antwort haben solltet, was ihr korrigiert habt, streicht das durch, da die ansonsten diesen Teil der Aufgabe nicht bewerten k√∂nnen/Punkte abziehen.
-Pinselt beim Use-Case-Diagramm keine lustigen Fig√ºrchen hin. Auch wenn das ein Auto ist, ist das im Use-Case-Diagramm ein Strichm√§nnchen.
-Bei einem "extend" im Use-Case-Diagramm ist die Zweiteilung des Kreises angebracht (3. Anforderungsanalyse - 3.4. Use Case Modellierung, Folie 48)
-Bei Statcharts ist es nicht erlaubt, dass man zwei unterschiedliche Ereignis[Bedingung]/Aktion auf einen Pfeil schreibt, auch wenn das sch√∂ner aussieht.
-Bei Featurediagrammen mit dem XOR aufpassen, ein Schelm k√∂nnte bei nem "gespaltenem" XOR bei drei Optionen m√∂glicherweise reininterpretieren, dass das zwei XOR statt ein XOR ist. Aber da kann man dann in der Einsicht diskutieren.

-Merkt euch den weirden Stuff mit semantischer Differenz von Featurediagrammen, das k√∂nnte drankommen.
-Allgemein kann alles drankommen ü§∑ .

## Kopplung und Koh√§sion

Ist vermutlich wichtig, aber auch wenig

> Koh√§sion ist ein Ma√ü f√ºr die innere Zusammengeh√∂rigkeit von Elementen eines Moduls. Hei√üt wenn es ein Element gibt, dass nicht mit den anderen Elementen zutun hat, ist die Koh√§sion niedrig. $\Rightarrow$ H√∂he Koh√§sion, mehr besser

> Kopplung ist das Ma√ü der Zusammenhang zwischen Modulen. Man m√∂chte zum Beispiel das UI Framework doch auch vielleicht mal austauschen, hierf√ºr braucht man Schwache Kopplung $\Rightarrow$ Schwache Kopplung, weniger = besser

## Prototyping

Prototyping ist eigentlich das was ich hier gerade betreibe, eine Vorversion von etwas, um es zu testen. Es gibt die Folgenden Subarten:

- explorativ: Zur Analyse in der Analysephase. Wir danach nicht weiterentwickelt.
- experimentell: F√ºr Entwickler, um zu testen. Wird auch normalerweise nicht weiterentwickelt.
- evolution√§r: Der Zustand der Software wird st√§ndig weiterentwickelt.

## DevOps

Ganz spannendes Thema... halt wirklich.
Wenn man schon so _agile_ in der Entwicklung ist, ists ja bl√∂d, wenn ich dann auf das Operations Team warten muss, bis die mal wieder meine Software updaten.

Deswegen gibt es das Continuous Delivery. Hei√üt das automatisierte (kontinuierliche) Deployment von Software. Bei mir wird automatisch der master-Branch auf dem [Repo](https://github.com/jonsch318/htwr-aachen.de) deployed.

Continuous Integration hei√üt das automatische zusammenf√ºhren der Komponenten hei√üt hier linken, testen und compilen. [GitLab](https://git.rwth-aachen.de) integriert ci in seiner Platform.

## Security

Naja parsed nicht Sprachen aller Art (csv, java, etc...) mit Regex und vorallem nicht mit String concatenation.

XSS: Cross site scripting: Eine anderer Benutzer oder Seite kann Code auf deiner Seite ausf√ºhren.
SQL Injection: Ein anderer Benutzer oder Seite kann beliebige SQL-Statements auf deiner Datenbank ausf√ºhren.

## Architekturmuster

K√∂nnte auch ein eigenes Doc sein, hatte aber keine Lust:

- MVC: Model View Controller: Trennung von Daten, Darstellung und Logik
- Layered: Trennung in verschiedene Schichten (z.B. Datenbank, Business, UI)
- Pipes: Daten flie√üen durch Pipes durch. (z.B. unix-pipes)
- Blackboard: Daten werden an einem Punkt (Blackboard) gesammelt, worauf mehrere Komponenten zugreifen. (z.B. AST in Compilern)
- Proxy: Zwischenst√ºck zwischen zwei Komponenten. (z.B. Proxy-Server)

## Code-Generierung & Digialisierung mit Monti\*

> DSL (domain-specific language => DSL??) ist eine Sprache, die f√ºr eine bestimmte Dom√§ne (z.B. Umgebung) entwickelt wurde (z.B. mit Monticore definitert).

> MontiGem erstellt einen digitalen Zwilling von z.B. einer Pumpe. Wenn du am digitalen Zwilling was ver√§nderst, wird das auch in der realen Pumpe ver√§ndert und umgekehrt.

## Versionsverwaltung

> Git ist der einzige Ort wo, code aufbewahrt werden sollte.

Es erm√∂glicht das gut zusammenarbeiten an einem Projekt.

Es gibt ein externen Speicherort (Remote) an dem ein Projekt (Repository) gespeichert wird. Beim `git clone` wird das Repository lokal kopiert.
Es gibt verschieden Versionen von Dateien (Branches), die √ºber den `git checkout` gewechselt werden k√∂nnen und √ºber merge/pull-requests zusammengef√ºhrt werden.

Es werden nur die √Ñnderungen gespeichert (Diffs), nicht die komplette Datei. Dadurch ist es m√∂glich, dass mehrere Leute an einer Datei arbeiten k√∂nnen,
die √Ñnderungen werden √ºber `git commit -m "Beschreibung"` lokal gespeichert und k√∂nnen √ºber `git push` auf den Remote gespeichert werden.
Sie k√∂nnen dann durch `git pull` oder `git fetch` zusammengef√ºhrt bzw. nur geladen werden.

x> Verfickte schei√üe lernt endlich _git_, es ist nicht schwer.

## Automatisierungen

Make, Gradle etc. sind Build-Tools. Sie k√∂nnen automatisch die Abh√§ngigkeiten von Projekten herstellen und die Projekte compilen/builden.

### Make

Hier falls es noch hilft eine kleine einf√ºhrung in Makefiles:

```make
# | target | dependencies | command |
prog: data.o main.o # <- Abh√§ngigkeiten
      cc data.o main.o ‚Äìo prog # <- Befehl
main.o: data.h main.h main.c
        cc ‚Äìc main.c
data.o: data.c data.h
        cc ‚Äìc data.c
clean: rm *.o prog
```

Bevor also prog ausgef√ºhrt wird, wird zuerst data.o und main.o ausgef√ºhrt usw. mit `make prog` f√ºhr man dann einen target aus.

### Maven

Maven konfiguriert man mit xml (`pom.xml`) Dateien, es ist deutlich komplizierter (Es organisiert die Dependencies und es gibt Repositories von √ñffentlichen Bibliotheken). Die gekennzeichneten Tags waren:

- groupID: Eindeutige Identifikation z.B. Java package
- artifactID: .jar Name
- version: Version des Projektes
- properties: Eigenschaften & Versionen des Projektes
- dependencies: Abh√§ngigkeiten des Projektes (Werden auch mit groupID und artifactID identifiziert)

### Gradle

Gradle ist nochmal ein St√ºck komplizierter es funktioniert in zwei Phasen:

- Konfiguration: Hier werden die Abh√§ngigkeiten und Plugins definiert => Abh√§ngigkeitsgraph wird erstellt
- Ausf√ºhrung: Hier werden die Tasks vom Abh√§ngigkeitsgraph ausgef√ºhrt und compiliert.

?> Wenn hierzu was spezifisches abgefragt wird, beginnt die Revolution.

## Sonstiges

Ja in den Folien ist noch viel mehr [√ºber Produktlinien] (vor allem unn√∂tiger M√ºll) aber

?> Ich hoffe nicht viel anderes kommt dran, sonst wird das hier noch l√§nger, zudem bedeutet jede Sekunde das hier zu schreiben hei√üt -1IQ.

x> Lernt die Diagrammtypen und die Umwandlung in Code mit Entwurfsmuster
